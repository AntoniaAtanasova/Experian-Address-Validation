<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Experian Address Validation - sample page</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;400&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="dist/css/demo.css">
    <link rel="stylesheet" type="text/css" href="dist/css/experian-address-validation.css">
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1" />
    <link rel="shortcut icon" href="./dist/images/favicon.png">
  </head>

  <body spellcheck="false">
    <div class="page-header">
      <img src="dist/images/logo.png" width="137" height="60" loading="eager" decoding="async" alt="Experian logo">
    </div>

    <div class="hero-header">
      <h1>Experian Address Validation</h1>
    </div>

    <div class="intro">
      <p>Welcome to our Experian Address Validation demo. Here you can try some of our available search types.</p>

      <form class="token-prompt hidden" onsubmit="addToken(); return false;">
        Please enter a valid token to get started:<br>
        <input type="text" name="token" class="token-input"> <button>Go</button><br>
        <small>Or <a href='https://github.com/experianplc/Experian-Address-Validation#tokens' target="_blank">find out how to get a token</a> if you don't have one.</small>
      </form>
    </div>

    <main>
      <div class="search-type-panel">
        <label for="country">Select country dataset</label>
          <select name="country" id="country">
            <!--Add/remove your supported countries here -->
            <option value="">Please select</option>
          </select>

        <label>Choose search type</label>
        <div class="search-type-dropdown">
          <label class="search-type-selector search-type-selected" for="autocomplete-radio" data-panel-type="autocomplete">
            <div class="panel-content">
              <h5 class="header">Predict the address as I type</h5>
              <input type="radio" name="search-type-radio" id="autocomplete-radio" value="autocomplete" checked>
              <a href="https://docs.experianaperture.io/address-validation/experian-address-validation/address-search-types/autocomplete/" target="_blank">Autocomplete</a> search is designed to provide accurate suggestions in real-time.
            </div>
          </label>
          <label class="search-type-selector" for="validate-radio" data-panel-type="validate">
            <div class="panel-content">
              <h5 class="header">Enter the full address, then get results</h5>
              <input type="radio" name="search-type-radio" id="validate-radio" value="validate">
              <a href="https://docs.experianaperture.io/address-validation/experian-address-validation/address-search-types/validate/" target="_blank">Validate</a> search is designed to verify complete addresses.
            </div>
          </label>
          <label class="search-type-selector" for="singleline-radio" data-panel-type="singleline">
            <div class="panel-content">
              <h5 class="header">Enter partial address, then get results</h5>
              <input type="radio" name="search-type-radio" id="singleline-radio" value="singleline">
              <a href="https://docs.experianaperture.io/address-validation/experian-address-validation/address-search-types/singleline/" target="_blank">Singleline</a> search is designed to find an exact or close match to an address based on two or three key address elements.
            </div>
          </label>
          <label class="search-type-selector" for="lookupv2-radio" data-panel-type="lookupv2">
            <div class="panel-content">
              <h5 class="header">Enter postcode or locality, then get results</h5>
              <input type="radio" name="search-type-radio" id="lookupv2-radio" value="lookupv2">
              <a href="https://docs.experianaperture.io/address-validation/experian-address-validation/address-search-types/lookup/#lookup-v2" target="_blank">Lookup v2</a> search is designed to determine locality information using postal/ZIP code of an address, & vice versa. You can also use what3words or UDPRN as an input (UK only).
            </div>
          </label>
        </div>
      </div>

      <form>
        <div class="loader loader-overlay hidden">
          <div class="spinner"></div>
        </div>

        <div class="promptset">
          <div class="address-field-inputs"></div>
          <button id="find-address-button" class="hidden">Find address</button>
        </div>

        <div class="formatted-address hidden">
          <label for="address_line_1">Address line 1</label>
          <input type="text" name="address_line_1" id="address_line_1">

          <label for="address_line_2">Address line 2</label>
          <input type="text" name="address_line_2" id="address_line_2">

          <label for="locality">City</label>
          <input type="text" name="locality" id="locality">

          <label for="region">State</label>
          <input type="text" name="region" id="region">

          <label for="postal_code">ZIP code</label>
          <input type="text" name="postal_code" id="postal_code">

          <label for="country">Country</label>
          <input type="text" name="country" id="country">
        </div>

        <div class="error-display hidden">
          <label class="error-msg"></label>
        </div>
      </form>

      <aside class="metadata invisible">
        <h2>Validated address information</h2>
        <div class="data-grid">
          <span id="confidence-key"></span><span id="confidence-value"></span>
          <span id="delivery-type-key"></span><span id="delivery-type-value"></span>
          <span id="delivery-address-key"></span><span id="delivery-address-value"></span>
          <span id="what3words-key" class="hidden"><img src="./dist/images/w3w.png"/></span><span id="what3words-value" class="hidden"></span>
        </div>
        <div class="components-collection hidden" id="components-collection">
          <h2>Components Collection</h2>
          <span class="collapsible">
            <span class="hide">[Hide]</span>
            <span class="show hidden">[Show]</span>
          </span>
          <div class="content"></div>
        </div>
        <div class="metadata-collection hidden" id="metadata-collection">
          <h2>Metadata Collection</h2>
          <span class="collapsible">
            <span class="hide">[Hide]</span>
            <span class="show hidden">[Show]</span>
          </span>
          <div class="content"></div>
        </div>
        <div class="enrichment hidden" id="enrichment">
          <h2>Enrichment</h2>
          <span class="collapsible">
            <span class="hide">[Hide]</span>
            <span class="show hidden">[Show]</span>
          </span>
          <div class="content"></div>
        </div>
        <div class="map hidden" id="map"></div>
        <a href="https://github.com/experianplc/Experian-Address-Validation" target="_blank" class="download-button">Download sample code</a>
      </aside>
    </main>

    <script src="dist/js/experian-address-validation.js"></script>
    <script>
      // Set the custom options
      var options = {
        searchType: 'autocomplete',
        maxSuggestions: 10,
        useSpinner: false,
        elements: {
          countryList: document.querySelector("select"),
          address_line_1: document.querySelector("input[name='address_line_1']"),
          address_line_2: document.querySelector("input[name='address_line_2']"),
          address_line_3: document.querySelector("input[name='address_line_2']"),
          locality: document.querySelector("input[name='locality']"),
          region: document.querySelector("input[name='region']"),
          postal_code: document.querySelector("input[name='postal_code']"),
          country: document.querySelector("input[name='country']"),
          lookupButton: document.querySelector("button#find-address-button")
        }
      };

      // Try and read a token from localStorage
      if (localStorage && localStorage.getItem('address-validation-token')) {
        options.token = localStorage.getItem('address-validation-token');
      }

      // Initialise address validation
      var address = new AddressValidation(options);
      var addressValidationMap, addressValidationW3wMarker, addressValidationGeoMarker;

      // Accept a new token from the token prompt and set this in the AddressValidation class
      function addToken() {
        address.setToken(document.querySelector('[name="token"]').value);
        document.querySelector('main').classList.remove('inactive');
        document.querySelector('.token-prompt').classList.add('hidden');

        // Save the token in localStorage for next time
        if (localStorage) {
          localStorage.setItem('address-validation-token', document.querySelector('[name="token"]').value);
        }
      }

      // populate the country dataset dropdown with the authorized country datasets
      address.events.on("post-datasets-update", function() {
        let countryListElement = options.elements.countryList;
        let optionElements = countryListElement.getElementsByTagName("option")
        for (index = optionElements.length - 1; index >= 0; index--) {
          let optionElement = optionElements[index];
          if (optionElement.innerText !== "Please select") {
            optionElement.parentNode.removeChild(optionElement);
          }
        }

        let countries = address.countryDropdown;
        for (const country of countries) {
          const optionElement = document.createElement("option");
          optionElement.setAttribute("value", country.iso3Code);
          optionElement.innerText = country.country;
          countryListElement.append(optionElement);
        }
      });

      // Show the large spinner while we're searching for the formatted address
      address.events.on("pre-formatting-search", function() {
        document.querySelector(".loader").classList.remove("hidden");
      });

      // Hide the large spinner when a result is found
      address.events.on("post-formatting-search", function(data) {
        document.querySelector(".loader").classList.add("hidden");

        if (data.result.confidence !== "No matches" || address.searchType === 'autocomplete') {
          // Show the formatted address fields
          document.querySelector(".formatted-address").classList.remove("hidden");
          document.querySelectorAll(".formatted-address .hidden").forEach(element => element.classList.remove("hidden"));
          // Hide the promptset as we have now captured the address
          document.querySelector('.promptset').classList.add('hidden');
        }

        // Populate the metadata section with more details about this address
        populateMetadata(data);
      });

      // Hide the formatted address container again upon reset
      address.events.on("post-reset", function() {
        document.querySelector(".formatted-address").classList.add("hidden");
        resetMetadata();
        document.querySelector('.promptset').classList.remove('hidden');
      });

      // Hide the loader if the request results in a 400 Bad Request error
      address.events.on("request-error-400", function() {
        document.querySelector(".loader").classList.add("hidden");
      });

      // Prompt for a token if the request is unauthorised (token is invalid or missing)
      address.events.on("request-error-401", function() {
        document.querySelector('main').classList.add('inactive');
        document.querySelector('.token-prompt').classList.remove('hidden');
      });

      // When the promptset is changed, update the form fields accordingly
      address.events.on("post-promptset-check", function(response) {
        const inputs = [];
        let errorElement = document.querySelector('.error-display');
        if (!errorElement.classList.contains("hidden")) {
          errorElement.classList.add('hidden');
          document.querySelector('.promptset').classList.remove('hidden');
        }
        // Clear any previous address input form fields
        document.querySelector('.address-field-inputs').innerHTML = "";

        // Iterate over each new line and create a new label and input
        response.result.lines.forEach((line, idx) => {
          const label = document.createElement("label");
          label.setAttribute("for", `address-input-${idx}`);
          label.innerText = line.prompt;

          let input;
          if (line.dropdown_options) {
            input = document.createElement("select");
            input.classList.add("address-input");
            input.setAttribute("id", `address-input-${idx}`);
            line.dropdown_options.forEach((dropdownOption) => {
              const optionElement = document.createElement("option");
              optionElement.setAttribute("value", dropdownOption.key);
              optionElement.innerText = dropdownOption.display;
              input.append(optionElement);
            });
          } else {
            input = document.createElement("input");
            input.classList.add("address-input");
            input.setAttribute("type", "text");
            input.setAttribute("id", `address-input-${idx}`);

            if (line.suggested_input_length) {
              input.setAttribute("size", line.suggested_input_length);
            }

            if (line.example) {
              input.setAttribute("placeholder", line.example);
            }
          }
          inputs.push(input);

          document.querySelector('.address-field-inputs').append(label, input);
        });

        // Register the event listeners on the new inputs
        address.setInputs(inputs);

        // Hide or show a "Find address" button depending on the search type
        document.querySelector("button#find-address-button").classList[
                (address.searchType !== "autocomplete") ? 'remove' : 'add']("hidden");
      });

      // To display error when unsupported search type is selected
      address.events.on("error-display", function (error) {
        document.querySelector('.promptset').classList.add('hidden');
        resetMetadata();
        document.querySelector('.formatted-address').classList.add('hidden');
        document.querySelectorAll('.formatted-address').forEach(element => element.classList.add('hidden'));

        let errorElement = document.querySelector('.error-display');
        errorElement.classList.remove('hidden');

        const labelElement = errorElement.getElementsByTagName('label')[0];
        labelElement.innerText = error;
      });

      // Display a map with the lat/long details after a data enrichment lookup
      address.events.on("post-enrichment", function(data) {
        if (address.geocodes.detailsMap.size > 0 || (data.result.what3words && data.result.what3words.latitude)) {
          document.querySelector("#map").classList.remove("hidden");          
          document.querySelector(".metadata #what3words-key").classList.add("hidden");
          document.querySelector(".metadata #what3words-value").classList.add("hidden");

          let enrichmentElement = document.querySelector("#enrichment");
          enrichmentElement.classList.remove("hidden");
          // populate cv household attributes
          populateAddressAdditionalInfo(address.cvHousehold.detailsMap, enrichmentElement, address.cvHousehold.title);

          // populate geocodes attributes
          populateAddressAdditionalInfo(address.geocodes.detailsMap, enrichmentElement, address.geocodes.title);

          // populate premium location insight
          populateAddressAdditionalInfo(address.premiumLocationInsightMap, enrichmentElement, "Premium Location Insight");

          let w3wLat, w3wLong, w3wLatLong;
          if (data.result.what3words && data.result.what3words.latitude) {            
            document.querySelector(".metadata #what3words-key").classList.remove("hidden");
            document.querySelector(".metadata #what3words-value").classList.remove("hidden");
            document.querySelector(".metadata #what3words-value").innerHTML = '///' + data.result.what3words.name;
            
            w3wLat = data.result.what3words.latitude;
            w3wLong = data.result.what3words.longitude;
            w3wLatLong = [w3wLat, w3wLong];
          } 
          
          let geoLat, geoLong, geoLatLong;
          if(data.result.nzl_regional_geocodes){
            geoLat = address.geocodes.detailsMap.get("Centroid of Property Latitude");
            geoLong = address.geocodes.detailsMap.get("Centroid of Property Longitude")
          } else {
            geoLat = address.geocodes.detailsMap.get("Latitude");
            geoLong = address.geocodes.detailsMap.get("Longitude")
          }
          if (geoLat && geoLong) {
            geoLatLong = [geoLat, geoLong];
          } 

          var zoom = 16;
          var attribution = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors';

          // Define a custom icon for what3words
          var w3wIcon = L.icon({
            iconUrl: './dist/images/w3w.loc.png',
            iconSize:     [30, 37], // size of the icon
            iconAnchor:   [15, 36], // point of the icon which will correspond to marker's location
            popupAnchor:  [0, -20] // point from which the popup should open relative to the iconAnchor
          });

          // Instantiate a new map
          if (!addressValidationMap) {
            // The hardcoded coordinated are needed to initialize the map. Will be overwritten with the what3words and geocode markers.
            addressValidationMap = L.map('map').setView([51.500264, 0.633506],zoom);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution}).addTo(addressValidationMap);
          } else {
            // Update the previous map instance by removing any existing markers
            if (addressValidationW3wMarker) {
              addressValidationW3wMarker.remove();
            }

            if (addressValidationGeoMarker) {
              addressValidationGeoMarker.remove();
            }
          }
          
          // Add new markers for location insight datasets
          var markerArray = [];
          if (w3wLatLong) {
            addressValidationMap.panTo(w3wLatLong, {duration: 1});
            addressValidationW3wMarker = L.marker(w3wLatLong, {icon: w3wIcon}).addTo(addressValidationMap);
            markerArray.push(addressValidationW3wMarker);
          } 

          if (geoLatLong) {
            addressValidationMap.panTo(geoLatLong, {duration: 1});
            addressValidationGeoMarker = L.marker(geoLatLong).addTo(addressValidationMap);
            markerArray.push(addressValidationGeoMarker);
          } 

          // Ensure all markers fit onto the map
          var group = L.featureGroup(markerArray);
          addressValidationMap.fitBounds(group.getBounds().pad(0.25));
        }
      });

      /* Demo specific code */
      // Allow the user to change the search type
      document.querySelectorAll('.search-type-selector').forEach(panel => panel.addEventListener('click', togglePanel));

      function togglePanel(e) {
        // Toggle which panel should be selected
        document.querySelectorAll('.search-type-selector').forEach(panel => panel.classList.remove('search-type-selected'));
        e.currentTarget.classList.add('search-type-selected');

        address.setSearchType(e.currentTarget.dataset.panelType);
      }

      // Display and populate the "metadata" container
      function populateMetadata(data) {
        // Try and get some geocoded enrichment data
        address.getEnrichmentData(data.result.global_address_key);

        const confidence = data.result.confidence;
        if (confidence) {
          document.querySelector(".metadata #confidence-key").innerText = confidence === 'Verified match' ? '✔' : '❌';
          document.querySelector(".metadata #confidence-value").innerText = confidence;
        }

        if (data.metadata && data.metadata.address_classification) {
          const deliveryType = data.metadata.address_classification.delivery_type;
          if (deliveryType) {
            document.querySelector(".metadata #delivery-type-key").innerText = deliveryType === 'residential' ? '🏡' : '🏢';
            document.querySelector(".metadata #delivery-type-value").innerText = deliveryType.substring(0, 1).toUpperCase() + deliveryType.substring(1);
          }
        }

        document.querySelector(".metadata #delivery-address-key").innerHTML = data.result.address ? '<img src="./dist/images/marker-icon-s.png"/>' : '';
        document.querySelector(".metadata #delivery-address-value").innerHTML = data.result.address ? Object.values(data.result.address).filter(line => line !== "").join("<br>") : '';
        document.querySelector(".metadata").classList.remove("invisible");

        populateAddressAdditionalInfo(address.componentsCollectionMap, document.querySelector("#components-collection"));
        populateAddressAdditionalInfo(address.metadataCollectionMap, document.querySelector("#metadata-collection"));
      }

      function populateAddressAdditionalInfo(collectionMap, parentElement, elementTitle) {
        if (collectionMap.size > 0) {
          let divElement = parentElement.getElementsByClassName("content")[0];
          parentElement.classList.remove("hidden");
          if (elementTitle) {
            const headerElement = document.createElement("h3");
            headerElement.innerText = elementTitle;
            divElement.append(headerElement);
          }

          collectionMap.forEach((value, key) => {
            const htmlSpanElement = document.createElement("span");
            let htmlBrElement = document.createElement("br");
            if (typeof value == "object") {
              htmlSpanElement.innerText = `${key}: `;
              divElement.append(htmlSpanElement, htmlBrElement);
              addChildElement(Object.entries(value), divElement, 1, true)
            } else {
              htmlSpanElement.innerText = `${key}: ${value}`;
              divElement.append(htmlSpanElement, htmlBrElement);
            }
          });
          divElement.append(document.createElement("br"));
          parentElement.append(divElement);
        }
      }

      function addChildElement(entries, componentCollectionsElement, level, addSubtitle) {
        for (const [childKey, childValue] of entries) {
          const htmlChildSpanElement = document.createElement("span");
          let htmlChildBrElement = document.createElement("br");
          htmlChildSpanElement.classList.add('tab');
          htmlChildSpanElement.setAttribute("style", "--spaces: " + level * 2 + "em;");
          if (typeof childValue == "object") {
            let childLevel = level;
            if(addSubtitle){
              htmlChildSpanElement.innerText = `${childKey}: `;
              childLevel = level + 1;
              componentCollectionsElement.append(htmlChildSpanElement, htmlChildBrElement);
            }
            addChildElement(Object.entries(childValue), componentCollectionsElement, childLevel,
                    !(Array.isArray(childValue) && childValue.length === 1));
          } else {
            htmlChildSpanElement.innerText = `${childKey}: ${childValue}`;
            componentCollectionsElement.append(htmlChildSpanElement, htmlChildBrElement);
          }
        }
      }

      // Hide the "metadata" container
      function resetMetadata() {
        document.querySelector(".metadata #confidence-key").innerText = '';
        document.querySelector(".metadata #confidence-value").innerText = '';
        document.querySelector(".metadata #delivery-type-key").innerText = '';
        document.querySelector(".metadata #delivery-type-value").innerText = '';
        document.querySelector(".metadata #what3words-key").classList.add("hidden");
        document.querySelector(".metadata #what3words-value").classList.add("hidden");

        document.querySelector(".metadata").classList.add("invisible");

        // to remove all components collection elements
        removeMetadataElements(document.getElementById("components-collection"));
        document.querySelector("#components-collection").classList.add("hidden");

        // to remove all metadata collection elements
        removeMetadataElements(document.getElementById("metadata-collection"));
        document.querySelector("#metadata-collection").classList.add("hidden");

        // to remove all enrichment elements
        removeMetadataElements(document.getElementById("enrichment"));
        document.querySelector("#enrichment").classList.add("hidden");

        document.querySelector("#map").classList.add("hidden");
      }

      function removeMetadataElements(parent) {
        parent.querySelector(".hide").classList.remove("hidden");
        parent.querySelector(".show").classList.add("hidden");

        let divElements = parent.querySelectorAll(".content");
        divElements.forEach(div => {
          div.style.display = "block";

          let spanElements = div.getElementsByTagName("span")
          for (index = spanElements.length - 1; index >= 0; index--) {
            let spanElement = spanElements[index];
            spanElement.parentNode.removeChild(spanElement);
          }

          let brElements = div.getElementsByTagName("br")
          for (brIndex = brElements.length - 1; brIndex >= 0; brIndex--) {
            let brElement = brElements[brIndex];
            brElement.parentNode.removeChild(brElement);
          }

          let subtitleElements = div.getElementsByTagName("h3")
          for (subTitleIndex = subtitleElements.length - 1; subTitleIndex >= 0; subTitleIndex--) {
            let subtitleElement = subtitleElements[subTitleIndex];
            subtitleElement.parentNode.removeChild(subtitleElement);
          }
        });
      }

      // to handle expand and collapse
      function onContentLoaded() {
        let collapsibleDivs = document.querySelectorAll(".collapsible");
        collapsibleDivs.forEach(div => {
          div.addEventListener('click', function () {
            let nextElementSibling = this.nextElementSibling;
            let parentElement = nextElementSibling.parentElement;
            let hideElement = parentElement.querySelector(".hide");
            let showElement = parentElement.querySelector(".show");
            if (nextElementSibling.style.display === "block") {
              nextElementSibling.style.display = "none";
              hideElement.classList.add("hidden");
              showElement.classList.remove("hidden");
            } else {
              nextElementSibling.style.display = "block";
              hideElement.classList.remove("hidden");
              showElement.classList.add("hidden");
            }
          })
        })
      }

      document.addEventListener("DOMContentLoaded", onContentLoaded);
    </script>
  </body>
</html>
